[{"x":"200px","y":"200px","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>WebGPU Hello Triangle</title>\n  <style>\n    canvas {\n      width: 400px;\n      height: 400px;\n      border: 1px solid black;\n    }\n  </style>\n</head>\n<body>\n  <canvas id=\"canvas\" width=\"400\" height=\"400\"></canvas>\n  <script type=\"module\">\n    // Check for WebGPU support\n    if (!navigator.gpu) {\n      alert(\"WebGPU not supported. Try Chrome/Edge with --enable-unsafe-webgpu\");\n      throw new Error(\"WebGPU not supported\");\n    }\n\n    const canvas = document.getElementById(\"canvas\");\n    const adapter = await navigator.gpu.requestAdapter();\n    const device = await adapter.requestDevice();\n    const context = canvas.getContext(\"webgpu\");\n\n    const format = navigator.gpu.getPreferredCanvasFormat();\n    context.configure({\n      device,\n      format,\n      alphaMode: \"opaque\"\n    });\n\n    // Vertex Shader (WGSL)\n    const vertexShaderCode = `\n      @vertex\n      fn main(@builtin(vertex_index) VertexIndex: u32) -> @builtin(position) vec4<f32> {\n        var pos = array<vec2<f32>, 3>(\n          vec2<f32>(0.0, 0.5),\n          vec2<f32>(-0.5, -0.5),\n          vec2<f32>(0.5, -0.5)\n        );\n        return vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n      }\n    `;\n\n    // Fragment Shader (WGSL)\n    const fragmentShaderCode = `\n      @fragment\n      fn main() -> @location(0) vec4<f32> {\n        return vec4<f32>(1.0, 0.0, 0.0, 1.0); // Red\n      }\n    `;\n\n    const pipeline = device.createRenderPipeline({\n      layout: \"auto\",\n      vertex: {\n        module: device.createShaderModule({ code: vertexShaderCode }),\n        entryPoint: \"main\"\n      },\n      fragment: {\n        module: device.createShaderModule({ code: fragmentShaderCode }),\n        entryPoint: \"main\",\n        targets: [{ format }]\n      },\n      primitive: {\n        topology: \"triangle-list\"\n      }\n    });\n\n    function draw() {\n      const encoder = device.createCommandEncoder();\n      const view = context.getCurrentTexture().createView();\n\n      const pass = encoder.beginRenderPass({\n        colorAttachments: [{\n          view: view,\n          loadOp: \"clear\",\n          storeOp: \"store\",\n          clearValue: { r: 0.1, g: 0.1, b: 0.1, a: 1.0 }\n        }]\n      });\n\n      pass.setPipeline(pipeline);\n      pass.draw(3);\n      pass.end();\n\n      device.queue.submit([encoder.finish()]);\n    }\n\n    draw();\n  </script>\n</body>\n</html>\n","sequence":1,"width":"1970px","height":"1077px"},{"x":"2261px","y":"343px","content":"<p>This is a second node</p>","sequence":2,"width":"359px","height":"113px"}]