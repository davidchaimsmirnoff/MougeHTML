<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mindmap Renderer</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      font-family: sans-serif;
    }

nav {
  display: flex;
  justify-content: flex-start; /* align buttons to the left */
  background: #222;
  color: white;
  padding: 10px 20px;
  font-size: 16px;
}

nav button {
  background: transparent;
  color: white;
  border: none;
  cursor: pointer;
  font-size: 16px;
  margin-right: 10px; /* space between buttons */
}
    #mindmapWrapper {
      width: 100vw;
      height: calc(100vh - 40px);
      overflow: scroll;
      position: relative;
    }

    #mindmap {
      width: 5000px;
      height: 5000px;
      position: relative;
      background: repeating-linear-gradient(0deg, #f0f0f0 0 49px, #e0e0e0 50px),
                  repeating-linear-gradient(90deg, #f0f0f0 0 49px, #e0e0e0 50px);
    }

    .node {
      position: absolute;
      background: #fff;
      border: 1px solid #999;
      border-radius: 6px;
      min-width: 120px;
      min-height: 80px;
      overflow: hidden;
    }

    .node textarea {
      width: 100%;
      height: calc(100% - 12px);
      box-sizing: border-box;
      resize: none;
      border: none;
      padding: 5px;
      background: transparent;
    }

    .resizer {
      width: 12px;
      height: 12px;
      background: #ccc;
      position: absolute;
      right: 0;
      bottom: 0;
      cursor: se-resize;
      z-index: 10;
    }

    .sequence-number {
      font-weight: bold;
      color: blue;
      padding: 4px;
      display: none;
    }

    .edit-icons {
      position: absolute;
      top: 2px;
      right: 2px;
      display: none;
    }

    .edit-icons button {
      margin-left: 3px;
      font-size: 12px;
    }

    #iframeView {
      display: none;
      width: 100vw;
      height: 100vh;
    }

    iframe {
      width: 100%;
      height: 100%;
      border: none;
    }



    .node .rich {
  width: 100%;
  height: calc(100% - 12px);
  box-sizing: border-box;
  padding: 5px;
  outline: none;
  overflow: auto;
  white-space: pre-wrap;
  font: 14px/1.4 monospace;
  background: transparent;
  border: none;
}


.kw { color: red; font-weight: 600; }

    #modal, #helpModal {
      position: fixed;
      top: 25%;
      left: 30%;
      width: 40%;
      background: white;
      border: 2px solid black;
      padding: 20px;
      display: none;
      z-index: 1000;
    }


    
    /* === Inline syntax colors === */
.tok.comment { color:#6a737d; font-style: italic; }
.tok.string  { color:#032f62; }
.tok.number  { color:#005cc5; }
.tok.keyword { color:#d73a49; font-weight:600; }
.tok.regex   { color:#22863a; }
.tok.op      { color:#24292e; }

.tok.tag     { color:#22863a; font-weight:600; }     /* <div, </p */
.tok.attr    { color:#6f42c1; }                      /* href, class */
.tok.eq      { color:#24292e; }                      /* = */
.tok.entity  { color:#005cc5; }                      /* &amp; etc */

.tok.selector{ color:#b31d28; }                      /* .class, #id, h1 */
.tok.cssprop { color:#005cc5; }                      /* color, margin */
.tok.cssval  { color:#032f62; }                      /* red, 12px */

#pageControls button { background:#333; color:#fff; border:1px solid #444; padding:4px 8px; border-radius:6px; }
#pageIndicator { cursor: default; }
.node { touch-action: none; } /* smoother touch drag */

#pageControlsWrapper {
  position: fixed;
  right: 12px;
  bottom: 12px;
  z-index: 1000;
  display: flex;
  flex-direction: column;  /* stack bar over arrows */
  align-items: center;
  gap: 6px;
}

#pageControls, #pageArrows {
  display: flex;
  align-items: center;
  background: rgba(34,34,34,.9);
  border: 1px solid #444;
  border-radius: 10px;
  padding: 6px 8px;
  gap: 6px;
}

#pageControls button, #pageArrows button {
  background:#333;
  color:#fff;
  border:1px solid #444;
  padding:4px 8px;
  border-radius:6px;
}
#pageIndicator { cursor: default; opacity: .9; }



#pageControls button { background:#333; color:#fff; border:1px solid #444; padding:4px 8px; border-radius:6px; }
#pageIndicator { cursor: default; opacity: .9; }

#pageArrows {
  display:flex;
  align-items:center;
  background: rgba(34,34,34,.9);
  border: 1px solid #444;
  border-radius: 10px;
  padding: 6px 8px;
  gap: 6px;
}
#pageArrows button {
  background:#333; color:#fff; border:1px solid #444;
  padding:4px 8px; border-radius:6px;
}
#pageArrowIndicator {
  min-width: 48px;          /* nice fixed width */
  text-align: center;
  color: #fff;
  opacity: .9;
  padding: 0 8px;
  font-weight: 600;
}


/* === Code Color Theme (HTML + CSS + JS tokens) === */
:root {
  /* base */
  --code-fg: #24292e;
  --code-bg: transparent;

  /* syntax */
  --c-comment: #6a737d;
  --c-string:  #032f62;
  --c-number:  #005cc5;
  --c-keyword: #d73a49; /* JS keywords: if, return, const, etc. */
  --c-regex:   #22863a;
  --c-op:      #24292e;
  --c-entity:  #005cc5; /* &amp; etc. */

  /* HTML */
  --c-tag:     #22863a; /* <div>, </p> */
  --c-attr:    #6f42c1; /* class, href, id */
  --c-eq:      #24292e; /* = */

  /* CSS */
  --c-selector:#b31d28; /* .class, #id, h1 */
  --c-prop:    #005cc5; /* color, margin */
  --c-val:     #032f62; /* red, 12px */
}

.node .rich { color: var(--code-fg); background: var(--code-bg); }

/* HTML tokens */
.node .rich .tok.tag     { color: var(--c-tag);     font-weight: 600; }
.node .rich .tok.attr    { color: var(--c-attr); }
.node .rich .tok.eq      { color: var(--c-eq); }
.node .rich .tok.entity  { color: var(--c-entity); }

/* CSS tokens */
.node .rich .tok.selector{ color: var(--c-selector); }
.node .rich .tok.cssprop { color: var(--c-prop); }
.node .rich .tok.cssval  { color: var(--c-val); }

/* General tokens */
.node .rich .tok.comment { color: var(--c-comment); font-style: italic; }
.node .rich .tok.string  { color: var(--c-string); }
.node .rich .tok.number  { color: var(--c-number); }
.node .rich .tok.keyword { color: var(--c-keyword); font-weight: 600; }
.node .rich .tok.regex   { color: var(--c-regex); }
.node .rich .tok.op      { color: var(--c-op); }



  </style>
</head>
<body>

<nav>
  <button onclick="toggleModal()">  <h2>üéπMougeHTML</h2></button>
  <button onclick="toggleModal()">   üéõÔ∏è Menu</button>
  <button onclick="document.getElementById('helpModal').style.display = 'block'">‚ú® Help</button>
</nav>




<div id="helpModal">
  <h3>‚ú® Keyboard Shortcuts</h3>
  <ul>
    <li>üñ•Ô∏è<code>` + W</code> ‚Äî Toggle Render Mode</li>
    <li>üî¢ <code>` + R</code> ‚Äî Toggle Render Sequence</li>
    <li>‚öôÔ∏è <code>` + E</code> ‚Äî Open Menu Modal</li>
    <li>üìù <code>` + Shift </code> ‚Äî Toggle Edit Mode</li>
  </ul>
  <button onclick="document.getElementById('helpModal').style.display = 'none'">Close</button>
</div>

<div id="mindmapWrapper"><div id="mindmap"></div></div>
<div id="iframeView"><iframe id="outputFrame"></iframe></div>
<div id="modal">
  <p>Save / Load / Delete</p>
  <button onclick="saveState()">Save</button>
  <button onclick="loadState()">Load</button>
  <button onclick="deleteState()">Delete</button>
  <button onclick="closeModal()">Close</button>
</div>

<div id="pageControlsWrapper">
  <div id="pageControls">
    <button id="pageMinus" title="Delete page">‚ûñ</button>
    <button id="pageIndicator" disabled>
      Page <span id="pageNumber">1</span>/<span id="pageTotal">1</span>
    </button>
    <button id="pagePlus" title="New page">‚ûï</button>
  </div>

<div id="pageArrows">
  <button id="pagePrev" title="Previous page">‚óÄÔ∏è</button>
  <span id="pageArrowIndicator" aria-label="Current page">1/1</span>
  <button id="pageNext" title="Next page">‚ñ∂Ô∏è</button>
</div>



</div>



<script>
const mindmap = document.getElementById("mindmap");
const modal = document.getElementById("modal");
const iframeView = document.getElementById("iframeView");

let nodes = [];
let shiftHeld = false;
let showSequence = false;
let mode = "mindmap";


let tickHeld = false;
let shiftHeldDown = false;
let wHeld = false;
let rHeld = false;
let eHeld = false;
let editHoldTimer = null;
let holdTimer = null;
let tickETimer = null;

let escHeld = false;

let tickHeldR = false;
let escWTimer = null;




const mindmapWrapper = document.getElementById("mindmapWrapper");

const outputFrame = document.getElementById("outputFrame");
let isDragging = false;


// Pages (3D)
let pages = [];      // [{ id, state: NodeState[] }]
let currentPage = 0; // index

function snapshotCurrentPage() {
  return nodes.map(n => ({
    x: n.el.style.left,
    y: n.el.style.top,
    content: n.getValue(),
    sequence: parseInt(n.seqDisplay.textContent),
    width: n.el.style.width,
    height: n.el.style.height
  }));
}
function clearDOMNodes() {
  nodes.forEach(n => mindmap.removeChild(n.el));
  nodes = [];
}
function loadPageState(state) {
  clearDOMNodes();
  (state || []).forEach(n => {
    const x = parseInt(n.x), y = parseInt(n.y);
    const w = n.width  || "150px";
    const h = n.height || "100px";
    createNode(x, y, n.content, n.sequence, w, h);
  });
}
function ensureCurrentSnap() {
  if (!pages.length) return;
  pages[currentPage].state = snapshotCurrentPage();
}


//Below Helpers 

function goToPage(index) {
  if (!pages.length) return;
  ensureCurrentSnap(); // save current DOM -> snapshot
  currentPage = ((index % pages.length) + pages.length) % pages.length; // wrap
  loadPageState(pages[currentPage].state);
  updatePageUI();

  // optional: reset scroll for a clean view
  mindmapWrapper.scrollLeft = 0;
  mindmapWrapper.scrollTop  = 0;
}
function nextPage() { goToPage(currentPage + 1); }
function prevPage() { goToPage(currentPage - 1); }

//PEV PAGE NEXT PAGE

document.getElementById("pagePlus").onclick = () => {
  ensureCurrentSnap();
  pages.push({ id: `p${pages.length+1}`, state: [] });   // blank page
  goToPage(pages.length - 1);                             // jump to it
};

document.getElementById("pageMinus").onclick = () => {
  if (pages.length <= 1) return alert("Can't delete the last page.");
  ensureCurrentSnap();
  pages.splice(currentPage, 1);
  goToPage(Math.max(0, currentPage - 1));                 // land on previous
};



//RIGHT AFTER 
document.getElementById("pageNext").onclick = nextPage;
document.getElementById("pagePrev").onclick = prevPage;


//hoisted above 

// live highlighter for `<html>`
function escapeHTML(s) {
  return s.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
}

//FIXING 

function saveSelection(root) {
  const sel = window.getSelection();
  if (!sel || sel.rangeCount === 0) return null;
  const r = sel.getRangeAt(0);

  // offsets relative to root's textContent
  const preStart = r.cloneRange();
  preStart.selectNodeContents(root);
  preStart.setEnd(r.startContainer, r.startOffset);
  const start = preStart.toString().length;

  const preEnd = r.cloneRange();
  preEnd.selectNodeContents(root);
  preEnd.setEnd(r.endContainer, r.endOffset);
  const end = preEnd.toString().length;

  return { start, end };
}

function restoreSelection(root, pos) {
  if (!pos) return;
  const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);
  let cur = 0, n, sNode=null, sOff=0, eNode=null, eOff=0;

  while ((n = walker.nextNode())) {
    const next = cur + n.nodeValue.length;
    if (sNode === null && pos.start <= next) { sNode = n; sOff = pos.start - cur; }
    if (eNode === null && pos.end   <= next) { eNode = n; eOff = pos.end   - cur; break; }
    cur = next;
  }
  if (sNode && eNode) {
    const sel = window.getSelection();
    sel.removeAllRanges();
    const r = document.createRange();
    r.setStart(sNode, Math.max(0, sOff));
    r.setEnd(eNode,   Math.max(0, eOff));
    sel.addRange(r);
  }
}


function escapeHTML(s) {
  return s.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
}

function highlightLive(ed) {
  const caret = saveSelection(ed);        // keep cursor in place

  const raw  = ed.innerText;              // 1) plain text from editor
  const safe = escapeHTML(raw);           // 2) escape < > &

  // 3) Highlight tags like <h1>, </div>, <p class="x">
  //    We wrap the whole tag in .tok.tag and then highlight the inside pieces.
  let html = safe.replace(
    /(&lt;\/?)([a-zA-Z][\w-]*)([^&]*?)(&gt;)/g,
    (m, lt, tagName, inside, gt) => {
      // Inside the tag, highlight attributes: name, =, "string"
      const highlightedInside = inside
        // attr name
        .replace(/(\s+)([a-zA-Z_:][\w:.-]*)/g, (m2, ws, name) => `${ws}<span class="tok attr">${name}</span>`)
        // equals
        .replace(/=/g, '<span class="tok eq">=</span>')
        // quoted strings "..." or '...'
        .replace(/(".*?"|'.*?')/g, '<span class="tok string">$1</span>');

      return `<span class="tok tag">${lt}${tagName}${highlightedInside}${gt}</span>`;
    }
  );

  // 4) Optional: highlight DOCTYPE, comments, numbers, etc.
  html = html
    .replace(/(&lt;!--[\s\S]*?--&gt;)/g, '<span class="tok comment">$1</span>')   // HTML comments
    .replace(/\b\d+(\.\d+)?\b/g, '<span class="tok number">$&</span>');          // numbers

  if (ed.innerHTML !== html) ed.innerHTML = html;

  restoreSelection(ed, caret);            // restore cursor
}

// Tag names + basic JS syntax (keywords, strings, numbers)
function highlightLive(ed) {
  const caret = saveSelection(ed);

  const raw  = ed.innerText || "";
  let html = raw
    .replace(/&/g,"&amp;")
    .replace(/</g,"&lt;")
    .replace(/>/g,"&gt;");

  // --- JS strings (", ', `) ---
  html = html.replace(
    /("([^"\\]|\\.)*"|'([^'\\]|\\.)*'|`([^`\\]|\\.)*`)/g,
    '<span style="color:#032f62">$1</span>'
  );

  // --- Numbers ---
  html = html.replace(
    /\b\d+(\.\d+)?\b/g,
    '<span style="color:#005cc5">$&</span>'
  );

  // --- JS keywords ---
  const KW = [
    "const","let","var","function","return","if","else","for","while",
    "switch","case","break","continue","new","class","extends",
    "try","catch","finally","throw","import","export","from",
    "await","async","yield","this","null","true","false","in","of",
    "typeof","instanceof","delete","void"
  ];
  const kwRe = new RegExp("\\b(" + KW.join("|") + ")\\b","g");
  html = html.replace(kwRe, '<span style="color:#d73a49;font-weight:600">$1</span>');

  // --- HTML tag names (<div>, </h1>, <p>) ---
  html = html.replace(
    /(&lt;\/?)(\w+)([^&]*?&gt;)/gi,
    (m, open, tag, rest) => `${open}<span style="color:#22863a;font-weight:600">${tag}</span>${rest}`
  );

  ed.innerHTML = html;
  restoreSelection(ed, caret);
}





/* === ONE-PASTE FIX: tag-only live highlight for all .rich editors === */
(function () {
  // 1) Override highlighter: only color tag names (<div>, </h1>, <p>), keep rest plain
  window.highlightLive = function (ed) {
    if (!ed) return;
    const caret = (window.saveSelection ? saveSelection(ed) : null);

    const raw  = ed.innerText || "";
    const safe = raw.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");

    const html = safe.replace(
      /(&lt;\/?)(\w+)([^&]*?&gt;)/gi,
      (m, open, tag, rest) => `${open}<span style="color:#22863a;font-weight:600">${tag}</span>${rest}`
    );

    ed.innerHTML = html;
    if (caret && window.restoreSelection) restoreSelection(ed, caret);
  };

  // 2) Attach live behavior to an editor once
  function initEditor(ed) {
    if (!ed || ed.dataset.tagsInit) return;
    ed.dataset.tagsInit = "1";

    // live re-paint, coalesced via rAF
    let scheduled = false, composing = false;
    const schedule = () => {
      if (scheduled || composing) return;
      scheduled = true;
      requestAnimationFrame(() => { scheduled = false; highlightLive(ed); });
    };

    ed.addEventListener("input", schedule);
    ed.addEventListener("keyup", schedule);
    ed.addEventListener("cut", schedule);
    ed.addEventListener("drop", schedule);

    ed.addEventListener("compositionstart", () => composing = true);
    ed.addEventListener("compositionend",  () => { composing = false; schedule(); });

    // plain-text paste only
    ed.addEventListener("paste", (e) => {
      e.preventDefault();
      const t = (e.clipboardData || window.clipboardData).getData("text/plain");
      document.execCommand("insertText", false, t);
    });

    // initial paint
    highlightLive(ed);
  }

  // 3) Init existing editors
  document.querySelectorAll(".rich[contenteditable]").forEach(initEditor);

  // 4) Auto-init future editors created by your app
  const root = document.getElementById("mindmap") || document.body;
  new MutationObserver((muts) => {
    for (const m of muts) {
      m.addedNodes && m.addedNodes.forEach(n => {
        if (n.nodeType !== 1) return;
        if (n.matches?.(".rich[contenteditable]")) initEditor(n);
        n.querySelectorAll?.(".rich[contenteditable]").forEach(initEditor);
      });
    }
  }).observe(root, { childList: true, subtree: true });
})();


//Create NODE

          function createNode(x, y, content = "", sequence = 0, width = "150px", height = "100px") {
            const node = document.createElement("div");
            node.className = "node";
            node.style.left = `${x}px`;
            node.style.top = `${y}px`;
            node.style.width = width;
            node.style.height = height;

            const seqDisplay = document.createElement("div");
            seqDisplay.className = "sequence-number";
            seqDisplay.textContent = sequence;
            seqDisplay.style.display = showSequence ? "block" : "none";

            // --- Rich editor ---
            const editor = document.createElement("div");
            editor.className = "rich";
            editor.contentEditable = "true";
            editor.textContent = content;

            // initial highlight (now that content is set)
            highlightLive(editor);

            // Enter inserts newline (code-editor style)
            editor.addEventListener("keydown", (e) => {
              if (e.key === "Enter") {
                e.preventDefault();
                document.execCommand("insertHTML", false, "\n");
                highlightLive(editor);
              }
            });

            // Tab inserts 4 spaces
            editor.addEventListener("keydown", (e) => {
              if (e.key === "Tab") {
                e.preventDefault();
                document.execCommand("insertText", false, "    ");
              }
            });

            // Re-highlight while typing

            // --- Edit icons ---
            const icons = document.createElement("div");
            icons.className = "edit-icons";

            const editBtn = document.createElement("button");
            editBtn.textContent = "‚úèÔ∏è";
            editBtn.onclick = () => {
              editor.contentEditable = (editor.contentEditable === "true") ? "false" : "true";
            };

            const delBtn = document.createElement("button");
            delBtn.textContent = "‚ùå";
            delBtn.onclick = () => deleteNode(node);

            icons.appendChild(editBtn);
            icons.appendChild(delBtn);

            // --- Resizer ---
            const resizer = document.createElement("div");
            resizer.className = "resizer";
            node.appendChild(resizer);

            resizer.addEventListener("mousedown", (e) => {
              e.stopPropagation();
              e.preventDefault();

              const startX = e.clientX;
              const startY = e.clientY;
              const startWidth = parseInt(getComputedStyle(node).width, 10);
              const startHeight = parseInt(getComputedStyle(node).height, 10);

              function doDrag(ev) {
                node.style.width = `${startWidth + ev.clientX - startX}px`;
                node.style.height = `${startHeight + ev.clientY - startY}px`;
              }
              function stopDrag() {
                document.removeEventListener("mousemove", doDrag);
                document.removeEventListener("mouseup", stopDrag);
              }
              document.addEventListener("mousemove", doDrag);
              document.addEventListener("mouseup", stopDrag);
            });

            // ---- Drag Logic (no jump, scroll-safe) ----
            node.addEventListener("pointerdown", (e) => {
              if (e.target.closest(".resizer") || e.target.closest(".rich")) return;
              if (e.target.closest(".edit-icons")) return;
              if (mode !== "mindmap") return;

              isDragging = true;
              node.setPointerCapture(e.pointerId);

              const startX = e.clientX;
              const startY = e.clientY;
              const startLeft = parseFloat(node.style.left) || 0;
              const startTop  = parseFloat(node.style.top)  || 0;

              const startScrollLeft = mindmapWrapper.scrollLeft;
              const startScrollTop  = mindmapWrapper.scrollTop;

              const onMove = (ev) => {
                const dx = (ev.clientX - startX) + (mindmapWrapper.scrollLeft - startScrollLeft);
                const dy = (ev.clientY - startY) + (mindmapWrapper.scrollTop  - startScrollTop);
                node.style.left = `${startLeft + dx}px`;
                node.style.top  = `${startTop  + dy}px`;
                document.body.style.userSelect = "none";
              };

              const onUp = (ev) => {
                isDragging = false;
                node.releasePointerCapture(ev.pointerId);
                node.removeEventListener("pointermove", onMove);
                node.removeEventListener("pointerup", onUp);
                document.body.style.userSelect = "";
              };

              node.addEventListener("pointermove", onMove);
              node.addEventListener("pointerup", onUp);
            });

            // --- Append ---
            node.appendChild(seqDisplay);
            node.appendChild(icons);
            node.appendChild(editor);
            mindmap.appendChild(node);

            // Sequence editing (when overlay is visible)
            node.addEventListener("click", () => {
              if (showSequence && shiftHeld) {
                const newVal = prompt("Edit Sequence Number:", seqDisplay.textContent);
                const newSeq = parseInt(newVal);
                if (!isNaN(newSeq)) {
                  seqDisplay.textContent = newSeq;
                  const current = nodes.find(n => n.el === node);
                  if (current) current.sequence = newSeq;
                }
              }
            });

            // Register in state
            nodes.push({
              el: node,
              editor,
              seqDisplay,
              sequence,
              getValue: () => editor.innerText
            });
          }



//Function RECEIVER

  const functionMap = {
    toggleMode,
  };

  window.addEventListener('message', (event) => {
    // Optional: Security check for trusted iframe
    // if (event.origin !== 'https://your-trusted-iframe.com') return;

    const { type, functionName, args } = event.data;

    if (type === 'runFunction' && functionMap[functionName]) {
      functionMap[functionName](...(args || []));
    }
  });


function deleteNode(node) {
  if (!node || !node.parentNode) return;
  mindmap.removeChild(node);
  nodes = nodes.filter(n => n.el !== node);
}


function renderOutput() {
  const sorted = [...nodes]
    .filter(n => n.seqDisplay.textContent !== '0')
    .sort((a, b) => parseInt(a.seqDisplay.textContent) - parseInt(b.seqDisplay.textContent));

  const code = sorted.map(n => n.getValue()).join('\n');
  const doc = outputFrame.contentDocument || outputFrame.contentWindow.document;
  doc.open(); doc.write(code); doc.close();
}

/*
function toggleMode() {
  const wrapper = document.getElementById("mindmapWrapper");
  if (mode === "mindmap") {
    mode = "render";
    wrapper.style.display = "none";
    iframeView.style.display = "block";
    renderOutput();
  } else {
    mode = "mindmap";
    iframeView.style.display = "none";
    wrapper.style.display = "block";
  }
}

*/

function toggleMode() {
  const wrapper = document.getElementById("mindmapWrapper");

  if (mode === "mindmap") {
    mode = "render";
    wrapper.style.display = "none";
    iframeView.style.display = "block";
    
ensureCurrentSnap();  // save current page before rendering
const all = [];
pages.forEach((p, idx) => {
  (p.state || []).forEach(n => {
    const s = parseInt(n.sequence);
    if (!isNaN(s) && s !== 0) {
      all.push({ seq: s, content: n.content, pageIndex: idx });
    }
  });
});
all.sort((a,b)=> a.seq - b.seq);

const code = all.map(n => n.content).join("\n");

    const fullDoc = `
      <html>
        <head>
          <style>
            body { margin: 0; font-family: monospace; }
          </style>
        </head>
        <body>
          ${code}
          <script>
            let tickHeld = false;
            let wHeld = false;
            let holdTimer = null;

            document.addEventListener("keydown", function(e) {
              if (e.key === "\`") tickHeld = true;
              if (e.key.toLowerCase() === "w") wHeld = true;
              if (tickHeld && wHeld && !holdTimer) {
                holdTimer = setTimeout(() => {
                  parent.postMessage("TOGGLE_BACK", "*");
                }, 500);
              }
            });

            document.addEventListener("keyup", function(e) {
              if (e.key === "\`") tickHeld = false;
              if (e.key.toLowerCase() === "w") wHeld = false;
              clearTimeout(holdTimer);
              holdTimer = null;
            });
          <\/script>
        </body>
      </html>
    `;

    const doc = outputFrame.contentDocument || outputFrame.contentWindow.document;
    doc.open();
    doc.write(fullDoc);
    doc.close();

  } else {
    mode = "mindmap";
    iframeView.style.display = "none";
    wrapper.style.display = "block";
  }
}
  window.onload = () => {
  window.toggleMode = toggleMode;
  window.saveState = saveState;
  window.loadState = loadState;
  window.deleteState = deleteState;
  window.createNode = createNode;
};


function toggleRenderSequence() {
  showSequence = !showSequence;
  nodes.forEach(n => {
    n.seqDisplay.style.display = showSequence ? "block" : "none";
    n.editor.style.display = showSequence ? "none" : "block";
  });
}

function toggleModal() {
  modal.style.display = modal.style.display === "block" ? "none" : "block";
}

function closeModal() {
  modal.style.display = "none";
}

function saveState() {
  const name = prompt("Enter a name for this save:");
  if (!name) return;
  ensureCurrentSnap();
  const payload = { currentPage, pages };
  fetch(`/api/save/${name}`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload)
  })
  .then(r=>r.text()).then(msg=>alert(msg))
  .catch(err=>alert("Save failed: " + err));
}

function loadState() {
  fetch("/api/list").then(r=>r.json()).then(list => {
    if (list.length === 0) return alert("No saves found.");
    let menu = "Choose a save to load:\n\n";
    list.forEach((name,i)=> menu += `${i+1}. ${name}\n`);
    const idx = parseInt(prompt(menu));
    if (isNaN(idx) || idx<1 || idx>list.length) return alert("Invalid selection.");

    const saveName = list[idx-1];
    fetch(`/api/load/${saveName}`).then(r=>r.json()).then(state => {
      if (Array.isArray(state)) { // legacy: single page
        pages = [{ id: "p1", state }];
        currentPage = 0;
      } else {
        pages = (state.pages || []).map((p,i)=>({ id: p.id || `p${i+1}`, state: p.state || [] }));
        currentPage = Math.min(Math.max(0, parseInt(state.currentPage)||0), pages.length-1);
      }
      loadPageState(pages[currentPage].state);
      updatePageUI();
      alert(`Loaded: ${saveName}`);
    }).catch(err=>alert("Failed to load save: " + err));
  }).catch(err=>alert("Failed to fetch saves: " + err));
}

/*

function loadState() {
  fetch("/api/list")
    .then(res => res.json())
    .then(list => {
      if (list.length === 0) return alert("No saves found.");

      let menu = "Choose a save to load:\n\n";
      list.forEach((name, i) => {
        menu += `${i + 1}. ${name}\n`;
      });

      const choice = prompt(menu);
      const index = parseInt(choice);
      if (isNaN(index) || index < 1 || index > list.length) {
        return alert("Invalid selection.");
      }

      const saveName = list[index - 1];
      fetch(`/api/load/${saveName}`)
        .then(res => res.json())
        .then(state => {
          // Clear current nodes
          nodes.forEach(n => mindmap.removeChild(n.el));
          nodes = [];

          // Load saved state
          state.forEach(n => {
            const x = parseInt(n.x);
            const y = parseInt(n.y);
            const content = n.content;
            const sequence = n.sequence;
            const width = n.width || "150px";
            const height = n.height || "100px";
            createNode(x, y, content, sequence, width, height);
          });

          alert(`Loaded: ${saveName}`);
        });
    })
    .catch(err => alert("Failed to load saves: " + err));
}
*/


function deleteState() {
  fetch("/api/list")
    .then(res => res.json())
    .then(list => {
      if (list.length === 0) return alert("No saves found to delete.");

      let menu = "Choose a save to delete:\n\n";
      list.forEach((name, i) => {
        menu += `${i + 1}. ${name}\n`;
      });

      const choice = prompt(menu);
      const index = parseInt(choice);
      if (isNaN(index) || index < 1 || index > list.length) {
        return alert("Invalid selection.");
      }

      const saveName = list[index - 1];
      fetch(`/api/delete/${saveName}`, {
        method: "DELETE"
      })
        .then(res => res.text())
        .then(msg => alert(msg))
        .catch(err => alert("Delete failed: " + err));
    })
    .catch(err => alert("Failed to fetch saves: " + err));
}






//1 second hold of esc and w 



document.addEventListener("keydown", function(e) {
    if (e.key === "`") tickHeld = true;
    if (e.key.toLowerCase() === "w") wHeld = true;

    if (tickHeld && wHeld && !holdTimer) {
      holdTimer = setTimeout(() => {
        parent.postMessage("TOGGLE_BACK", "*");
      }, 300);
    }
  });

  document.addEventListener("keyup", function(e) {
    if (e.key === "`") tickHeld = false;
    if (e.key.toLowerCase() === "w") wHeld = false;
    clearTimeout(holdTimer);
    holdTimer = null;
  });

document.addEventListener("keyup", (e) => {
  if (e.key === "Escape") escHeld = false;
  if (e.key.toLowerCase() === "w") wHeld = false;

  if (!escHeld || !wHeld) {
    clearTimeout(escWTimer);
    escWTimer = null;
  }
});


window.addEventListener("message", (event) => {
  if (event.data === "TOGGLE_BACK") {
    toggleMode(); // Switch back to editor
  }
});

//syntaxHIghlighting 

function replaceTextareaWithSyntax(nodeEl, language = "javascript") {
  const textarea = nodeEl.querySelector("textarea");
  if (!textarea) return;

  const code = document.createElement("code");
  code.className = `language-${language}`;
  code.contentEditable = "true";
  code.style.whiteSpace = "pre-wrap";
  code.style.outline = "none";
  code.style.display = "block";
  code.style.height = "calc(100% - 12px)";
  code.style.padding = "5px";
  code.textContent = textarea.value;

  const pre = document.createElement("pre");
  pre.appendChild(code);
  pre.style.margin = "0";
  pre.style.height = "calc(100% - 12px)";
  pre.style.overflow = "auto";

  textarea.replaceWith(pre);

  // Re-highlight on input
  code.addEventListener("input", () => {
    Prism.highlightElement(code);
  });

  Prism.highlightElement(code);

  // Optional: add code accessor for saving
  nodeEl.__getCode = () => code.textContent;
}




//TOggle Render Sequence 

let tickRTimer = null;

document.addEventListener("keydown", (e) => {
  if (e.key === "`") tickHeldR = true;
  if (e.key.toLowerCase() === "r") rHeld = true;

  if (tickHeldR && rHeld && !tickRTimer) {
    tickRTimer = setTimeout(() => {
      toggleRenderSequence();
    }, 300); // Hold for 1/2 a second
  }
});

document.addEventListener("keyup", (e) => {
  if (e.key === "`") tickHeldR = false;
  if (e.key.toLowerCase() === "r") rHeld = false;

  if (!tickHeldR || !rHeld) {
    clearTimeout(tickRTimer);
    tickRTimer = null;
  }
});


//Toggle Modal

let tickHeldE = false;

document.addEventListener("keydown", (e) => {
  if (e.key === "`") tickHeldE = true;
  if (e.key.toLowerCase() === "e") eHeld = true;

  if (tickHeldE && eHeld && !tickETimer) {
    tickETimer = setTimeout(() => {
      toggleModal();
    }, 300); // Half a second hold
  }
});

document.addEventListener("keyup", (e) => {
  if (e.key === "`") tickHeldE = false;
  if (e.key.toLowerCase() === "e") eHeld = false;

  if (!tickHeldE || !eHeld) {
    clearTimeout(tickETimer);
    tickETimer = null;
  }
});







document.addEventListener("keyup", (e) => {
  if (e.key === "`") tickHeld = false;
  if (e.key === "Shift") shiftHeldDown = false;

  if (!tickHeld || !shiftHeldDown) {
    clearTimeout(editHoldTimer);
    editHoldTimer = null;
  }

});


function updatePageUI() {
  const num = document.getElementById("pageNumber");
  const tot = document.getElementById("pageTotal");
  const arrowInd = document.getElementById("pageArrowIndicator");      // ‚Üê add
  if (num && tot) {
    num.textContent = (currentPage + 1);
    tot.textContent = pages.length;
  }
  if (arrowInd) arrowInd.textContent = `${currentPage + 1}/${pages.length}`; // ‚Üê add
}


//Shift + ` holded for 1 second fires this

document.addEventListener("keydown", (e) => {
  if (e.key === "`") tickHeld = true;
  if (e.key === "Shift") shiftHeldDown = true;

  if (tickHeld && shiftHeldDown && !editHoldTimer) {
    editHoldTimer = setTimeout(() => {
      shiftHeld = !shiftHeld; // üîÅ Toggle actual edit mode
      nodes.forEach(n => {
        n.el.querySelector(".edit-icons").style.display = shiftHeld ? "block" : "none";
      });
    }, 300); // ‚è± 1 second hold
  }
});


/*

document.addEventListener("keydown", (e) => {
  if (e.key === "Shift") {
    shiftHeld = !shiftHeld;
    nodes.forEach(n => {
      n.el.querySelector(".edit-icons").style.display = shiftHeld ? "block" : "none";
    });
  }
});

*/




//fullscreen 

document.addEventListener("fullscreenchange", () => {
  if (!document.fullscreenElement) {
    // Automatically re-enter fullscreen (‚ö†Ô∏è aggressive)
    // document.documentElement.requestFullscreen();
  }
});

//UPDATE



//shortcut flip pages 

document.addEventListener("keydown", (e) => {
  if (e.key === "`") tickHeld = true;
  if (tickHeld && e.key === "ArrowRight") { e.preventDefault(); nextPage(); }
  if (tickHeld && e.key === "ArrowLeft")  { e.preventDefault(); prevPage(); }
});
document.addEventListener("keyup", (e) => { if (e.key === "`") tickHeld = false; });


mindmap.addEventListener("click", (e) => {
  if (shiftHeld && e.target === mindmap) {
    const mapRect = mindmap.getBoundingClientRect();
    const x = e.clientX - mapRect.left + mindmapWrapper.scrollLeft;
    const y = e.clientY - mapRect.top  + mindmapWrapper.scrollTop;
    createNode(x, y, "<p>New Node</p>", nodes.length + 1);
  }
});

// put this at the very bottom of your script:

// if you want demo nodes only when canvas is empty:
if (nodes.length === 0) {
  createNode(200, 200, "<h1>Hello</h1>", 1);
  createNode(400, 200, "<p>This is a second node</p>", 2);
}

// seed page system with whatever nodes currently exist
pages = [{ id: "p1", state: snapshotCurrentPage() }];
currentPage = 0;
updatePageUI();


</script>


</body>
</html>
